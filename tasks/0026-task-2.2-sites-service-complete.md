# Subtask 2.2 - Sites Service - COMPLETE ✅

**Date:** October 20, 2025  
**Status:** ✅ COMPLETE  
**Time:** ~2 hours (estimated 3-4 hours)  
**Parent Task:** TASK 2 - Backend API (Sites & Layouts)

---

## Overview

Created `SitesService` class to handle business logic for site management. Implements Mapbox geocoding integration, PostGIS bbox validation, optimistic concurrency control with version tokens, and graceful error handling.

---

## Deliverables

### File Created
- **`src/services/sites.service.ts`** (210 lines)

### Service Methods

#### 1. `create(data: SiteCreateInput): Promise<Site>`
**Purpose:** Create site with optional geocoding  

**Geocoding Flow:**
```typescript
// Priority order:
1. If location provided manually → use it (skip geocoding)
2. Else if address provided + Mapbox available → geocode address
3. Else → proceed without location (nullable column)
```

**Implementation Details:**
- Constructs geocode query from `address, city, state, country, postal_code`
- Calls `forwardGeocode()` from `geocode.service.ts` (wraps Mapbox SDK)
- If geocoding fails (Mapbox token missing or API error):
  - Logs warning with `Logger`
  - Continues creating site without location (graceful degradation)
- Validates bbox using `validatePitchPolygon()` from `src/lib/geospatial.ts`
- Throws `AppError(400, 'INVALID_BBOX')` if validation fails

**Example:**
```typescript
// Scenario 1: Manual location (skips geocoding)
const site1 = await service.create({
  club_id: 1,
  name: 'Phoenix Park',
  location: { type: 'Point', coordinates: [-6.3294, 53.3562] }
});

// Scenario 2: Address-based geocoding
const site2 = await service.create({
  club_id: 1,
  name: 'Griffith Park',
  address: '4730 Crystal Springs Dr',
  city: 'Los Angeles',
  state: 'CA'
});
// → Calls Mapbox API → geocodes to coordinates

// Scenario 3: No Mapbox token (graceful degradation)
const site3 = await service.create({
  club_id: 1,
  name: 'Unknown Location Site',
  address: '123 Main St'
});
// → Mapbox call fails → location = null (valid, column is nullable)
```

---

#### 2. `get(id: number): Promise<Site>`
**Purpose:** Fetch site by ID  
**Error Handling:**
- Throws `AppError(404, 'SITE_NOT_FOUND')` if site doesn't exist or is soft-deleted

---

#### 3. `listPaginated(clubId: number, limit: number, cursor?: string): Promise<Site[]>`
**Purpose:** Fetch sites for a club with cursor-based pagination  
**Delegation:** Directly calls `repo.findByClubId()`  
**Note:** Service returns raw array; controller handles `paginateResults()` to generate `next_cursor` and `has_more`

---

#### 4. `update(id: number, versionToken: string, data: SiteUpdateInput): Promise<Site>`
**Purpose:** Update site with optimistic concurrency control  

**Version Token Flow:**
```typescript
// 1. Check version token
const isValid = await repo.checkVersionToken(id, versionToken);
if (!isValid) throw AppError(409, 'VERSION_CONFLICT');

// 2. Validate bbox if provided
if (data.bbox) {
  const error = validatePitchPolygon(data.bbox);
  if (error) throw AppError(400, 'INVALID_BBOX');
}

// 3. Perform update (regenerates version_token)
const updated = await repo.update(id, data);
```

**Error Handling:**
- `409 VERSION_CONFLICT`: Version token is stale (site was modified by another client)
- `400 INVALID_BBOX`: PostGIS polygon validation failed
- `404 SITE_NOT_FOUND`: Site doesn't exist or was soft-deleted

**Logging:**
- Logs version conflicts with site ID and provided token

---

#### 5. `delete(id: number, versionToken: string): Promise<void>`
**Purpose:** Soft delete site with version token check  

**Flow:**
```typescript
// 1. Check version token
const isValid = await repo.checkVersionToken(id, versionToken);
if (!isValid) throw AppError(409, 'VERSION_CONFLICT');

// 2. Soft delete (sets deleted_at timestamp)
const deleted = await repo.softDelete(id);
if (!deleted) throw AppError(404, 'SITE_NOT_FOUND');
```

**Error Handling:**
- Same as `update()`: 409 for version conflicts, 404 for not found

---

## Acceptance Criteria Validation

### ✅ Geocoding Integration
- [x] Manual location takes priority over geocoding
- [x] Address geocoding via Mapbox API
- [x] Graceful degradation if Mapbox unavailable
- [x] Logs geocoding success/failure

### ✅ PostGIS Validation
- [x] Validates bbox using `validatePitchPolygon()`
- [x] Checks: polygon structure, WGS84 bounds, self-intersection, winding order
- [x] Throws `AppError(400, 'INVALID_BBOX')` with error message

### ✅ Version Token Handling
- [x] Calls `repo.checkVersionToken()` before update/delete
- [x] Throws `AppError(409, 'VERSION_CONFLICT')` if stale
- [x] Logs version conflicts for debugging

### ✅ Error Handling
- [x] Throws `AppError` with status codes (404, 400, 409)
- [x] Uses structured logging (`Logger` from `src/lib/logger.ts`)
- [x] Graceful degradation for Mapbox failures

### ✅ Type Safety
- [x] All methods fully typed (no `any` types in public API)
- [x] Imports `Site`, `SiteCreateInput`, `SiteUpdateInput` from repository
- [x] TypeScript compilation passes (`npm run check:types`)

---

## Technical Implementation

### Mapbox Integration
```typescript
// Geocoding query construction
const geocodeQuery = [
  data.address,      // "4730 Crystal Springs Dr"
  data.city,         // "Los Angeles"
  data.state,        // "CA"
  data.country,      // "USA"
  data.postal_code   // "90027"
]
  .filter(Boolean)   // Remove undefined values
  .join(', ');       // "4730 Crystal Springs Dr, Los Angeles, CA, USA, 90027"

// Mapbox API call
const result = await forwardGeocode(geocodeQuery, 1);

// Extract coordinates from first result
const [lon, lat] = result.features[0].center;
const location = { type: 'Point', coordinates: [lon, lat] };
```

### PostGIS Validation
```typescript
// Validates:
// 1. Polygon structure (valid GeoJSON, closed ring)
// 2. WGS84 bounds (longitude [-180, 180], latitude [-90, 90])
// 3. Self-intersection (no crossing edges)
// 4. Winding order (counter-clockwise per RFC 7946)

const bboxError = validatePitchPolygon(data.bbox);
if (bboxError) {
  throw new AppError(
    `Invalid bbox: ${bboxError.message}`,
    400,
    'INVALID_BBOX'
  );
}
```

### Version Token Conflict Detection
```typescript
// Controller calls service with If-Match header value
const versionToken = req.headers['if-match']; // "550e8400-e29b-41d4-a716-446655440000"

// Service checks token before update
const isValid = await repo.checkVersionToken(id, versionToken);

// If another client updated the site in the meantime:
if (!isValid) {
  logger.warn('Version conflict', { siteId: id, providedToken });
  throw new AppError(
    'Version conflict: site was modified by another client. Please refresh and try again.',
    409,
    'VERSION_CONFLICT'
  );
}
```

---

## Error Handling Matrix

| Scenario | Status Code | Error Code | Message |
|----------|-------------|------------|---------|
| Site not found (get/update/delete) | 404 | `SITE_NOT_FOUND` | "Site not found" |
| Invalid bbox polygon | 400 | `INVALID_BBOX` | "Invalid bbox: {validation error}" |
| Version token is stale | 409 | `VERSION_CONFLICT` | "Version conflict: site was modified..." |
| Mapbox geocoding fails | (no error) | (none) | Logs warning, continues without location |

---

## Testing Strategy (Deferred to Subtask 2.6)

### Unit Tests (Future)
```typescript
describe('SitesService', () => {
  describe('create()', () => {
    it('should use manual location if provided', async () => {
      const result = await service.create({
        club_id: 1,
        name: 'Test',
        location: { type: 'Point', coordinates: [-6.26, 53.35] }
      });
      expect(result.location.coordinates).toEqual([-6.26, 53.35]);
      // Geocoding should NOT be called
    });

    it('should geocode address if no location provided', async () => {
      const result = await service.create({
        club_id: 1,
        name: 'Test',
        address: 'Dublin, Ireland'
      });
      expect(result.location).toBeDefined();
      // Mapbox mock should have been called
    });

    it('should throw 400 for invalid bbox', async () => {
      await expect(service.create({
        club_id: 1,
        name: 'Test',
        bbox: {
          type: 'Polygon',
          coordinates: [[[0, 0], [1, 1]]] // Invalid: not closed
        }
      })).rejects.toThrow(AppError);
    });
  });

  describe('update()', () => {
    it('should throw 409 for stale version token', async () => {
      // Create site → get version_token → update site (changes token) → try to update with old token
      await expect(
        service.update(1, 'old-token-uuid', { name: 'New Name' })
      ).rejects.toThrow(AppError); // 409 VERSION_CONFLICT
    });
  });
});
```

### Integration Tests (Future)
Will test end-to-end with Supertest, mocked Mapbox API, real PostgreSQL + PostGIS

---

## Code Quality

### TypeScript Compliance
- ✅ Strict mode enabled
- ✅ All public methods fully typed
- ✅ No `any` types in public API (only internal Mapbox result parsing)

### Logging
- ✅ Uses structured `Logger` class
- ✅ Logs geocoding success/failure
- ✅ Logs version conflicts with context (site ID, token)

### Error Handling
- ✅ All errors use `AppError` with status codes
- ✅ Graceful degradation for Mapbox failures
- ✅ Clear error messages for version conflicts

---

## Dependencies

### Internal
- ✅ `src/data/sites.repo.ts` - Repository layer (CRUD operations)
- ✅ `src/services/geocode.service.ts` - Mapbox wrapper
- ✅ `src/lib/geospatial.ts` - PostGIS polygon validation
- ✅ `src/lib/logger.ts` - Structured logging
- ✅ `src/errors/index.ts` - AppError class

### External
- ✅ Mapbox Geocoding API (optional, graceful degradation if unavailable)

---

## Architectural Pattern

```
Controller Layer (HTTP)
    ↓
Service Layer (Business Logic) ← YOU ARE HERE
    ↓
Repository Layer (Database)
    ↓
PostgreSQL + PostGIS
```

**Service Layer Responsibilities:**
- Business logic (geocoding flow, validation rules)
- Error handling (version conflicts, not found errors)
- Logging (audit trail for debugging)
- Orchestration (call multiple repositories if needed)

**What Service Layer Does NOT Do:**
- HTTP request/response handling (controller's job)
- Raw SQL queries (repository's job)
- Database schema definition (migration's job)

---

## Comparison with Existing Services

### Similar to `VenuesService`
- Both use optimistic concurrency (version tokens)
- Both delegate to repository for database operations
- Both throw `AppError` with status codes

### Differs from `VenuesService`
- Sites have **geocoding integration** (Venues do not)
- Sites have **PostGIS bbox validation** (Venues only validate pitches)
- Sites support **graceful degradation** for missing Mapbox token

---

## Next Steps

### Immediate (Subtask 2.3)
Create `src/schemas/sites.schema.ts` with:
- `SiteCreateSchema` - Validates GeoJSON location/bbox
- `SiteUpdateSchema` - Partial version of create schema
- `SiteResponseSchema` - Output format with version_token
- `SitesListResponseSchema` - Paginated response with `data[]`, `next_cursor`, `has_more`

### Dependencies
- ✅ Repository layer complete (Subtask 2.1)
- ✅ Service layer complete (Subtask 2.2)
- ⏳ Schemas layer (Subtask 2.3 - next)

---

## Files Modified

- **Created:** `src/services/sites.service.ts` (210 lines)
- **Modified:** None

---

## Completion Checklist

- [x] All service methods implemented (create, get, listPaginated, update, delete)
- [x] Mapbox geocoding integrated with graceful degradation
- [x] PostGIS bbox validation implemented
- [x] Version token checks before update/delete
- [x] Structured logging for debugging
- [x] TypeScript types validated (no errors)
- [x] Error handling follows 4-layer pattern
- [x] Code documented with JSDoc comments
- [x] Ready for controller integration

---

**Status:** ✅ COMPLETE  
**Actual Time:** ~2 hours  
**Quality:** Production-ready  
**Next:** Subtask 2.3 - Sites Zod Schemas (validation layer)

---

**Related Files:**
- Service: `src/services/sites.service.ts`
- Repository: `src/data/sites.repo.ts` (Subtask 2.1)
- Geocoding: `src/services/geocode.service.ts`
- Validation: `src/lib/geospatial.ts`
- Logging: `src/lib/logger.ts`
- Next Subtask: [tasks/0023-task-2-subtasks.md](./0023-task-2-subtasks.md) (Subtask 2.3)
